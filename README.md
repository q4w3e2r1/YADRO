# Тестовое задание YADRO 2025
Выполнил: Зарафутдинов А.М.

## Теоретическая часть

1. Почему современные веб-приложения часто реализовывают с разделением на backend и frontend части? За что отвечает backend,  а за что frontend ?

Ответ:

2. Почему современный frontend часто реализовывают с помощью фрейморков (angular, react, vue.js) ? Почему часто на фронтенде используют стейт-менеджеры (redux, mobx) ? 

Ответ:

3. Зачем в веб приложениях использовать дизайн систему и компоненты? Почему бы не использовать просто  CSS?

Ответ:

4. Зачем придумали разные виды тестирования: юнит-тестирование, интеграционное тестирование, e2e тестирование? В чем разница и какое когда использовать?
## Практическая часть

**Условие:** *Представь, что тебе нужно разработать простой фронтенд для веб-приложения, состоящего из одной страницы. Эта страница разделена на три* блока:
1. *Блок с кнопками: "Получить данные", "Очистить данные", "Сохранить в CSV".*
2. *График: Отображает данные выбранной строки таблицы в виде столбчатой диаграммы (bar-chart).*
3. *Таблица: Хранит данные, полученные с сервера. По умолчанию выделена строка с наибольшим числовым значением. Данные из таблицы можно сохранить в CSV.*

*Твоя задача — описать на псевдокоде, как бы ты реализовал(-а) эту функциональность с использованием React и Redux. Также опиши, как бы ты организовал(-а) тестирование (юнит, интеграционное и E2E).*

### **Решение**

### 1. Реализация интерфейса ключевых компонент
Как написано в условии задания, всё приложение можно поделить на 3 основных основных части:

1.1 **Блок с кнопками** состоит из 3 одинаковых кнопок, единственное отличие это событие, которое должно произойти при нажатия на кнопку и как вариант визуал самой кнопки. В такой ситуации, чтобы не дублировать одинаковый шаблонный код для 3 кнопок, реализуем 1 компонент `Button.component.tsx`, который будет принимать в props: скрипт при нажатии, название, класс CSS.
Реализация компонента будет выглядеть так:
```tsx

type ButtonProps = {
  onClick: () => void;
  label: string;
  className?: string;
  disabled?: boolean;
  type?: 'button' | 'submit' | 'reset';
};

const Button: React.FC<ButtonProps> = ({
  onClick,
  label,
  className = '',
  disabled = false,
  type = 'button'
}) => {
  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled}
      className={`base-button ${className}`}
    >
      {label}
    </button>
  );
};

export default Button;

```

А его использование в компоненте `ButtonBar.component.tsx` может выглядеть так:
```tsx
const ButtonBar: React.FC<ButtonBarProps> = ({
  onSave,
  onFetch,
  onClear,
}) => {
  return (
    <div className={styles['data-controls']}>
      <Button 
        label="fetch" 
        onClick={onFetch} 
        className="fetch-button"
      />
      <Button
        label="clear"
        onClick={onClear}
        className="clear-button"
      />
        <Button
          label="save"
          onClick={onSave}
          className="save-button"
        />
    </div>
  );
};
```


1.2 **График bar-chat**